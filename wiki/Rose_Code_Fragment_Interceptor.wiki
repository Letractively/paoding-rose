拦截器代码参考

<wiki:toc max_depth="3" />


= "跟踪"拦截器 =

{{{
// 直接放在controllers或其子package下(也可以放到其他package下，但需要applicationContext配置)
package com.xiaonei.rose.usage.controllers;

public class TrackInterceptor extends ControllerInterceptorAdapter {
    // 调用控制器action方法之前,before方法被Rose调用
    @Override
    public Object before(Invocation inv) throws Exception {
        // 打印一个日志，看看即将要调用哪个控制器的哪个方法
        System.out.println("invoking " + inv.getControllerClass().getName() + "." + inv.getMethod().getName());
        // 返回true，表示继续下一个拦截器
        return true;
    }

    // 调用控制器action方法之后,after方法被Rose调用
    @Override
    public Object after(Invocation inv, Object instruction) throws Exception {
        // 调用结束后，打印一个结果
        System.out.println("return " + instruction + " by " + inv.getControllerClass().getName() + "." + inv.getMethod());
        // instruction是控制器或上一个拦截器返回的
        return instruction;
    }
}
}}}

= 登录验证拦截器 =
{{{
package com.xiaonei.rose.usage.controllers;

public class LoginRequiredInterceptor extends ControllerInterceptorAdapter {

    // 覆盖这个方法，表示只有标注@LoginRequired的控制器或方法才会被此拦截器拦截
    @Override
    public Class<? extends Annotation> getAnnotationClass() {
        return LoginRequired.class;
    }

    @Override
    public Object before(Invocation inv) throws Exception {
        HttpServletRequest request = inv.getRequest();
        // 在此，假设我们判断是否已经登录的方法是session是否存在
        // 当然，对于互联网应用来说，不能使用默认的这种session机制
        HttpSession session = request.getSession(false);
        if (session == null || session.getAttribute("user") == null) {
            // 如果没有登录，重定向到登录页面
            return "r:http://localhost/login?origURL=登录后返回的地址";
        }
        return true;
    }
}
}}}

*LoginRequired.java*
{{{
@Inherited
@Target( { ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LoginRequired {

}

}}}