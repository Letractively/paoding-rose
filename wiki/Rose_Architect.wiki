
= Rose和Spring的关系 =

作为一名现代的Java开发者，几乎是离不开Spring的。Spring是SpringSource.org公司提供的开源Java基础架构产品。我们并不完全迷信Spring，但从技术上讲Spring提供了很好的在web开发中使用的基础组件、基础容器，使得它得到我们很大的尊重。

因为Spring充分地使用面向对象原则开发使Spring的丰富基础组件具有良好的使用和复用，有关web的一些基础组件包括：参数对象绑定器、Multipart对象抽象、视图渲染器等。这些组件被 Spring 自己的 Spring-MVC 框架自己使用，同时也被 Rose 大量使用。

除了对spring基础组件的使用，实际最重要的是Rose极大重视了对Spring ApplicationContext的使用。因为ApplicationContext的强大、聪慧，使得Rose的架构变得轻松而简单。每种框架对对象都有它的管理策略，Rose从本质上就是将各种各样的对象放置在合适的ApplicationContext上，不同的ApplicationContext之间形成上下级关系，让Spring来管理，并和开发者自定义的ApplicationContext有机结合起来。所以，从Spring的角度出发，开发者可以把Rose看出成是Spring的另外一种配置方式。也因此，Spring的@Autowired 可在Rose的类中大量被使用。

当然，为了更好地完成WEB工作以及极大的贯彻约定，不在没有意义的多种选择中彷徨，我们提供了Spring所没有的(或不同的)、Rose特有的各种机制：URI映射机制、参数映射机制以及各种道具的关系假设(拦截器、错误处理器、参数解析器)、页面映射关系、国际化配置机制等等。

= Rose与类反射 =

使用Rose进行WEB开发，第一个程序可能就是在某个controllers package下创建了某控制器类。Rose的控制器不需要什么接口或继承扩展什么类。同时控制器类的WEB动作方法几乎也是普通方法：其一：我们对方法名或方法参数没有强制规定；其二、一个控制器可以包括多少个WEB动作方法不做数量限制。

在这种框架下，虽然我们 *有办法* 通过在运行时自动进行代码增强包装成Command而不使用类反射来实现目的，虽然预见到放在我们口袋里的方案比直接使用类反射技术性能肯定有所提高，但目前我们仍没有这种做，Rose仍直接是使用类反射技术来访问开发者定义的方法。这样的决定来自我们的经验：目前类反射看起来并不影响到我们WEB应用的性能和响应速度，而且在现代Java程序大量使用类反射技术环境中，单纯“优化”Rose成效 *预计* 有限。当然，在必要时，我们不会放过可能的一点点性能提供。

所以，到现在为止，开发者定义的控制器和方法最终是由Rose通过method.invoke方法调用(对于代理对象的，使用Proxy来调用，少见)来处理web请求。这是唯一的在“服务”状态中必使用的类反射地方。

为了提供Rose的服务性能，Rose在启动的时候，已经把所有的控制器类和WEB动作方法进行了“解读”。在这个阶段，Rose会把所有URI映射规则以及尽可能做的事事先做好(包括对method方法名以及相关要素的缓存)，使Rose在服务状态时，不用再通过类反射来做和类、方法有关的识别和判断，直接就可以从缓存里获取method对象以及相关的其他要素进行处理，相信这已经是类反射API的极致追求。

另外一个使用类反射的地方是，在控制器生命Bean参数的(表单对象)，这将促使Rose使用类反射技术，把或请求对象中获取的参数进行转化动态设置到Bean的属性中。

